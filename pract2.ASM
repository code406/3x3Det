;**************************************************************************
; SBM 2019. PRACTICA 2 - ANA ROA, DAVID PALOMO. PAREJA 10.
; CALCULA EL DETERMINANTE DE UNA MATRIZ 3X3 CON DIGITOS ENTRE -16 Y 15
;**************************************************************************

; DEFINICION DEL SEGMENTO DE DATOS
DATOS SEGMENT
	CLR_PANT 	DB 	1BH,"[2","J$"
	; LINEAS DE IMPRESION.   A11(10,11,12) A12(14,15,16) A13(18,19,20)
	M1   DB 32, 8 DUP (0), "| 12 -12   3 |        ", 13, 10, '$'
	M2   DB 32,    "|A|  =  | 14  15  -5 | =      ", 13, 10, '$'
	M3   DB 32, 8 DUP (0), "|  1   0 -16 |        ", 13, 10, '$'
	; MATRIZ CONVERTIDA A VALORES DECIMALES
	MDEC DB 12,-12,3,  14,15,-5,  1,0,-16
	; GUARDA LOS 3 PRE-RESULTADOS QUE LUEGO SE SUMAN Y RESTAN
	RES  DW 3 DUP (0)
	; TEXTO QUE EXPLICA AL USUARIO COMO SELECCIONAR LA OPCION DE PROGRAMA
	INSTRUC1 DB 1BH,"[22;LSELECCIONA OPCION DE PROGRAMA:", 13, 10, "$"
	INSTRUC2 DB 1BH,"[22;L1)CALCULAR EL DETERMINANTE CON VALORES POR DEFECTO", 13, 10, "$"
	INSTRUC3 DB 1BH,"[22;L2)CALCULAR EL DETERMINANTE CON VALORES INTRODUCIDOS POR TECLADO", 13, 10, 13, 10, "$"
	; TEXTO QUE EXPLICA AL USUARIO COMO INTRODUCIR LOS NUMEROS POR TECLADO
	TEXTO DB 1BH,"[22;LINTRODUCE 9 NUMEROS (ENTRE -16 Y 15) SEPARADOS POR UN ESPACIO", 13, 10, "$"
	TEXTO2 DB 1BH,13,10,"EJEMPLO:    12 -12 3 14 15 -5 1 0 -16 <ENTER>", 13, 10, 13, 10, "$"
	; TEXTO QUE AVISA A USUARIO DE SU ERROR AL INTRODUCIR OPCION POR TECLADO
	ERROR_MSG DB 1BH,13,10,13,10,"ERROR AL INTRODUCIR LA OPCION. ESCRIBE '1' O '2'", 10, 13, "CERRANDO PROGRAMA", 13, 10, "$"
	; VARIABLE DONDE ALMACENAMOS LOS VALORES ASCII QUE LEEMOS POR PANTALLA
	NUMEROS DB 37 DUP(0)
	; ALMACENA LA MATRIZ EN ASCII PARA POSTERIOR PASO A LAS LINEAS
	INPUT DB 36 DUP(0)
	; ALMACENA LA OPCION ELEGIDA POR USUARIO
	OPCION DB 2 DUP(0)

DATOS ENDS
;_______________________________________________________________
; DEFINICION DEL SEGMENTO DE PILA
PILA SEGMENT STACK "STACK"
	DB 40H DUP (0)
PILA ENDS
;_______________________________________________________________
; DEFINICION DEL SEGMENTO DE CODIGO
CODE SEGMENT
ASSUME CS:CODE,DS:DATOS,SS:PILA

;---------------------------------------------------------------
; ------------- PROCEDIMIENTO PRINCIPAL: MAIN  -----------------
; --------------------------------------------------------------
MAIN PROC FAR

	MOV AX,DATOS
	MOV DS,AX            ;INICIALIZACION DE REGISTROS DE SEGMENTO

	CALL ASK_FOR_OPTION  ; SOLICITA OPCION, LA GUARDA EN AL
	CMP AL, 49           ; SI OPCION = 1
	JE REALIZAR_CALCULOS ;   SALTA A CALCULOS CON MATRIZ POR DEFECTO
	CMP AL, 50           ; SI OPCION = 2
    JE PEDIR_VALORES     ;   SOLICITA INTRODUCCION DE VALORES
	CALL ERROR_OPCION    ; SI OPCION NO ES 1 O 2, TERMINA EL PROGRAMA

PEDIR_VALORES:
	CALL ASK_FOR_VALUES  ; GUARDA VALORES ASCII EN LA TABLA "NUMEROS"
	CALL ASCII_TO_MDEC   ; CONVIERTE "NUMEROS" DE ASCII A DECIMAL
	CALL INPUT_TO_LINES  ; PASA LOS VALORES ASCII A LAS 3 LINEAS

REALIZAR_CALCULOS:
	CALL CALCULATE_DET   ; GUARDA RESULTADO DEL DETERMINANTE EN AX
	CALL AX_TO_ASCII     ; CONVIERTE AX A ASCII PARA IMPRIMIR
	CALL PRINT_LINES     ; IMPRIME LAS 3 LINEAS DE LA MATRIZ

MAIN_END:
	MOV AX,4C00H         ; FIN DE PROGRAMA Y VUELTA AL DOS
	INT 21H

MAIN ENDP



;-------------------------------------------------------------
; --------------  SUBRUTINA ASK_FOR_OPTION: ------------------
; SOLICITA 1 O 2 POR TECLADO AL USUARIO Y LO GUARDA EN OPCION
; ------------------------------------------------------------
ASK_FOR_OPTION PROC NEAR

	; BORRA LA PANTALLA
	MOV AH, 9
	MOV DX, OFFSET CLR_PANT
	INT 21H
	; IMPRIME TEXTO EXPLICATIVO PARA ELEGIR OPCION
	MOV DX, OFFSET INSTRUC1
	INT 21H
	MOV DX, OFFSET INSTRUC2
	INT 21H
	MOV DX, OFFSET INSTRUC3
	INT 21H
	; LEER UN CARACTER Y EL ENTER
	MOV AH, 0AH
	MOV DX, OFFSET OPCION
	MOV OPCION[0], 2
	INT 21H
	; DEVUELVE OPCION EN AL
	MOV AL, BYTE PTR OPCION[2]

RET
ASK_FOR_OPTION ENDP



;-------------------------------------------------------------
; --------------  SUBRUTINA ERROR_OPCION: --------------------
; IMPRIME POR PANTALLA MENSAJE DE ERROR Y TERMINA EL PROGRAMA
; ------------------------------------------------------------
ERROR_OPCION PROC NEAR

	MOV AH, 9
	MOV DX, OFFSET ERROR_MSG
	INT 21H        ; IMPRIME MENSAJE DE ERROR
	JMP MAIN_END   ; TERMINA EL PROGRAMA

RET
ERROR_OPCION ENDP



;-------------------------------------------------------------
; --------------  SUBRUTINA ASK_FOR_VALUES: ------------------
; SOLICITA VALORES DE MATRIZ A USUARIO Y LOS GUARDA EN NUMEROS
; ------------------------------------------------------------
ASK_FOR_VALUES PROC NEAR

	; BORRA LA PANTALLA
	MOV AH, 9
	MOV DX, OFFSET CLR_PANT
	INT 21H
	; TEXTO INFORMATIVO (INSTRUCCIONES DE FORMATO DE ENTRADA)
	MOV DX, OFFSET TEXTO
	INT 21H
	MOV DX, OFFSET TEXTO2
	INT 21H
	; LEE DE TECLADO LOS NUMEROS
	MOV AH, 0AH
	MOV DX, OFFSET NUMEROS
	MOV NUMEROS[0], 37		;NUMERO MAXIMO DE CARACTERES
	INT 21H

RET
ASK_FOR_VALUES ENDP



;-------------------------------------------------------------
; --------------  SUBRUTINA INPUT_TO_LINES: ------------------
; PASA LA CADENA "INPUT" A LAS LINEAS M1, M2 Y M3  -----------
; ------------------------------------------------------------
INPUT_TO_LINES PROC NEAR

	; INTRODUCE EN M1 LOS PRIMEROS 12 CARACTERES DE INPUT
	MOV BX, 0
PASARLINEA1:
	MOV AH, INPUT[BX]
	MOV M1[BX+10], AH
	INC BX
	CMP BX, 12
	JNE PASARLINEA1
	; INTRODUCE EN M2 LOS SIGUIENTES 12 CARACTERES DE INPUT
	MOV BX, 0
PASARLINEA2:
	MOV AH, INPUT[BX+12]
	MOV M2[BX+10], AH
	INC BX
	CMP BX, 12
	JNE PASARLINEA2
	; INTRODUCE EN M3 LOS ULTIMOS 12 CARACTERES DE INPUT
	MOV BX, 0
PASARLINEA3:
	MOV AH, INPUT[BX+24]
	MOV M3[BX+10], AH
	INC BX
	CMP BX, 12
	JNE PASARLINEA3

RET
INPUT_TO_LINES ENDP



;-------------------------------------------------------------
; --------------  SUBRUTINA AX_TO_ASCII: ---------------------
; SEPARA AX EN DIGITOS, LO CONVIERTE A ASCII Y LO GUARDA EN M2
; ------------------------------------------------------------
AX_TO_ASCII PROC NEAR

	; SI ES NEGATIVO, COMPLEMENTO A 2 (HACERLO POSITIVO)
	TEST AX, AX   ; PONE SF A 1 SI AX ES NEGATIVO
	JNS SINCOMP2  ; EVITA COMPLEMENTO A 2 SI AX POSITIVO
	MOV SI, 0C2H  ; SI: FLAG QUE INDICA QUE ES NEGATIVO
	NEG AX
SINCOMP2:

	; POR CADA DIVISION ENTRE 10, CONVIERTE RESTO A ASCII
	; Y ESCRIBE RESTO EN LINEA M2
	MOV BX, 0
SEPARA:
	MOV DX, 0
	MOV CX, 10
	IDIV CX         ; DIVIDE ENTRE 10. DX RESTO, AX COCIENTE
	ADD DL, 48         ; CONVIERTE RESTO A ASCII
	MOV M2[30+BX], DL  ; MOV DL A LINEA M2
	; I-- (IMPRIME DESDE LA DERECHA), SI COCIENTE='0' ACABA
	DEC BX
	CMP AX, 0000H
	JNE SEPARA

	; SI ES NEGATIVO, INTRODUCE "-" EN LINEA M2
	CMP SI, 0C2H ; COMPRUEBA SI ES NEGATIVO CON EL FLAG SI
	JNE SINMENOS ; EVITA INTRODUCIR EL "-" SI ES POSITIVO
	MOV M2[30+BX], 2DH
SINMENOS:

RET
AX_TO_ASCII ENDP



;-------------------------------------------------------------
; --------------  SUBRUTINA PRINT_LINES: ---------------------
; IMPRIMIR POR PANTALLA LAS LINEAS M1, M2 Y M3  --------------
; ------------------------------------------------------------
PRINT_LINES PROC NEAR

	; IMPRIME LA PRIMERA LINEA
	MOV BX,0
LINEA1:
	MOV DL,M1[BX+1]		;ESCRIBIR UN CARACTER
	MOV AH,2
	INT 21H
	INC BX
	CMP BL, M1[0]		;COMPARA CON NUM CARACTERES
	JNE LINEA1
	; IMPRIME LA SEGUNDA LINEA
	MOV BX,0
LINEA2:
	MOV DL,M2[BX+1]		;ESCRIBIR UN CARACTER
	MOV AH,2
	INT 21H
	INC BX
	CMP BL, M2[0]		;COMPARA CON NUM CARACTERES
	JNE LINEA2
	; IMPRIME LA TERCERA LINEA
	MOV BX,0
LINEA3:
	MOV DL,M3[BX+1]		;ESCRIBIR UN CARACTER
	MOV AH,2
	INT 21H
	INC BX
	CMP BL, M3[0]		;COMPARA CON NUM CARACTERES
	JNE LINEA3

RET
PRINT_LINES ENDP



;-------------------------------------------------------------
; --------------  SUBRUTINA ASCII_TO_MDEC: -------------------
; INTERPRETA LA INTRODUCCION DE USUARIO. ESCRIBE EN "MDEC" LOS
; VALORES DECIMALES Y EN "INPUT" UNA CADENA ASCII CON FORMATO.
; ------------------------------------------------------------
ASCII_TO_MDEC PROC NEAR

	; BUCLE PARA INTRODUCIR LOS 9 VALORES A LA MATRIZ DECIMAL
	MOV BX, 0
	MOV SI, 0 ; POSICION EN LA CADENA "NUMEROS"
BUCLE9:
	; DI: INDICE A PARTIR DEL QUE INSERTAR CADA NUMERO EN "INPUT"
	MOV AX, 4
	MUL BX
	MOV DI, AX

	MOV CX, SI
	; BUCLE PARA LEER CADA NUMERO EN LA CADENA
	MOV AL, 00H
	CONVERTIR:
		CMP NUMEROS[SI+2], 2DH  ;SI ES "-", NUMERO NEGATIVO
		JNE EVITARC2
		MOV AL, 0C2H  ;AL: FLAG QUE INDICA SI NUMERO ES NEGATIVO
		EVITARC2:
		CMP NUMEROS[SI+2], 20H ;SI ES ESPACIO, YA HA LEIDO EL NUMERO
		JE SALIRDELBUCLE
		CMP NUMEROS[SI+2], 13 ;SI ES ENTER, YA HA LEIDO EL NUMERO
		JE SALIRDELBUCLE
		; SI NO ES ESPACIO, ENTER O "-", ES UN NUMERO
		MOV DL, NUMEROS[SI+2]

		INC SI ; I++
		JMP CONVERTIR

	SALIRDELBUCLE:
	INC SI ; INCREMENTA POSICION PARA APUNTAR A SIGUIENTE LECTURA

	; CX: NUMERO DE ITERACIONES DE BUCLE CONVERTIR (ES 2, 3 O 4)
	NEG CX
	ADD CX, SI ; CX = SI-CX

	CMP CX, 2  ; SI CX=2, ES UN POSITIVO DE UN DIGITO
	JNE COMP2
	;INSERTA 2 ESPACIOS Y DL
	MOV INPUT[DI], 20H
	MOV INPUT[DI+1], 20H
	MOV INPUT[DI+2], DL
	JMP ATODEC
	COMP2:
		CMP CX, 4 ; SI CX=4, ES UN NEGATIVO DE DOS DIGITOS
		JNE COMP3
		; INSERTA -, 1, DL
		MOV INPUT[DI], 2DH
		MOV INPUT[DI+1], 49
		MOV INPUT[DI+2], DL
		ADD DL, 10 ;INCREMENTA 10 PORQUE ES NUMERO DE DOS CIFRAS
		JMP ATODEC
	COMP3:
		; COMPRUEBA SI ES POSITIVO DE DOS DIGITOS O NEGATIVO DE 1 DIGITO
		CMP AL, 0C2H
		JNE POS2DIG
		; INSERTA UN ESPACIO, UN - Y DL
		MOV INPUT[DI], 20H
		MOV INPUT[DI+1], 2DH
		MOV INPUT[DI+2], DL
		JMP ATODEC
	POS2DIG:
		; INSERTA 1 ESPACIO, UN 1 Y DL
		MOV INPUT[DI], 20H
		MOV INPUT[DI+1], 49
		MOV INPUT[DI+2], DL
		ADD DL, 10 ;INCREMENTA 10 PORQUE ES NUMERO DE DOS CIFRAS
	ATODEC:
		MOV INPUT[DI+3], 20H ;INTRODUCE ESPACIO SEPARADOR EN INPUT
		SUB DL, 48 ; CONVIERTE ASCII A DECIMAL
		CMP AL, 0C2H ; COMPRUEBA SI HAY QUE HACER EL COMPLEMENTO A 2
		JNE EVITACOMPL
		NEG DL
	EVITACOMPL:
		MOV MDEC[BX], DL ;INTRODUCE DECIMAL A LA MATRIZ
	INC BX
	CMP BX, 9
	JE BREAK  ;NECESARIO PORQUE EL BUCLE ES DEMASIADO LARGO
	JMP BUCLE9

BREAK:
RET
ASCII_TO_MDEC ENDP



;-------------------------------------------------------------
; --------------  SUBRUTINA CALCULATE_DET: -------------------
; CALCULA DETERMINANTE DE LA MATRIZ DECIMAL Y LO GUARDA EN AX
; ------------------------------------------------------------
CALCULATE_DET PROC NEAR

	;       A11 * (A22 * A33 - A32 * A23)
	;     - A12 * (A21 * A33 - A31 * A23)
	;     + A13 * (A21 * A32 - A31 * A22)
	;       -----------------------------
	;       AX (RESULT DECIMAL DE 2BYTES)

	; DX = A22 X A33
	MOV BX, 3*1
	MOV SI, 1
	MOV AL, MDEC[BX][SI]
	ADD BX, 3
	INC SI
	MOV CL, MDEC[BX][SI]
	IMUL CL
	MOV DX, AX
	; CX = A32 X A23
	DEC SI
	MOV AL, MDEC[BX][SI]
	SUB BX, 3
	INC SI
	MOV CL, MDEC[BX][SI]
	IMUL CL
	MOV CX, AX
	; AX = DX - CX
	MOV AX, DX
	SUB AX, CX
	; RES[2*0] = A11 X AX
	SUB BX, 3
	SUB SI, 2
	MOV CH, MDEC[BX][SI]
	MOV CL, 8
	SAR CX, CL	;EXTIENDE EN SIGNO EL BYTE DE LA CABEZA
	IMUL CX
	; RES[2*0]: RESULTADO DE LA PRIMERA OPERACION GRANDE
	MOV RES[2*0], AX

	;--------------

	; DX = A21 X A33
	ADD BX, 3
	MOV AL, MDEC[BX][SI]
	ADD BX, 3
	ADD SI, 2
	MOV CL, MDEC[BX][SI]
	IMUL CL
	MOV DX, AX
	; CX = A31 X A23
	SUB SI, 2
	MOV AL, MDEC[BX][SI]
	SUB BX, 3
	ADD SI, 2
	MOV CL, MDEC[BX][SI]
	IMUL CL
	MOV CX, AX
	; AX = DX - CX
	MOV AX, DX
	SUB AX, CX
	; RES[2*1] = A12 X AX
	SUB BX, 3
	DEC SI
	MOV CH, MDEC[BX][SI]
	MOV CL, 8
	SAR CX, CL	;EXTIENDE EN SIGNO EL BYTE DE LA CABEZA
	IMUL CX
	; RES[2*1]: RESULTADO DE LA SEGUNDA OPERACION GRANDE
	MOV RES[2*1], AX

	;--------------

	; DX = A21 X A32
	ADD BX, 3
	DEC SI
	MOV AL, MDEC[BX][SI]
	ADD BX, 3
	INC SI
	MOV CL, MDEC[BX][SI]
	IMUL CL
	MOV DX, AX
	; CX = A31 X A22
	DEC SI
	MOV AL, MDEC[BX][SI]
	SUB BX, 3
	INC SI
	MOV CL, MDEC[BX][SI]
	IMUL CL
	MOV CX, AX
	; AX = DX - CX
	MOV AX, DX
	SUB AX, CX
	; RES[2*2] = A13 X AX
	SUB BX, 3
	INC SI
	MOV CH, MDEC[BX][SI]
	MOV CL, 8
	SAR CX, CL	;EXTIENDE EN SIGNO EL BYTE DE LA CABEZA
	IMUL CX
	; RES[2*2]: RESULTADO DE LA TERCERA OPERACION GRANDE
	MOV RES[2*2], AX

	; SUMA Y RESTA DE LOS TRES RESULTADOS DE OP.GRANDES
	MOV AX, RES[2*0]
	SUB AX, RES[2*1] ; AX = RES[2*0] - RES[2*1]
	ADD AX, RES[2*2] ; AX = AX + RES[2*2]  (RESULTADO)

RET
CALCULATE_DET ENDP



; ------------------------------------------------------
;FIN DEL SEGMENTO DE CODIGO
CODE ENDS
;FIN DE PROGRAMA INDICANDO DONDE COMIENZA LA EJECUCION
END MAIN
